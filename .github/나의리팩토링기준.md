# 나의 리팩토링 기준

## 1. 계층 분리 원칙

- UI, 비즈니스 로직, 상태 관리 계층을 명확히 분리한다.
- 각 계층은 역할에 집중하며, 서로의 책임을 침범하지 않는다.

## 2. 비즈니스 로직 우선 분리 (models)

- 엔티티별 핵심 로직(계산, 검증 등)은 순수함수로 models에 먼저 구현한다.
- models는 외부 상태에 의존하지 않고, 테스트가 쉽도록 만든다.

## 3. 상태 관리 로직 분리 (hooks)

- 상태 관리와 side effect는 hook에서 담당한다.
- hook 내부에서 models의 순수함수를 활용한다.

## 4. UI 컴포넌트의 역할

- 컴포넌트는 오직 UI와 사용자 이벤트만 담당한다.
- 비즈니스 로직이나 상태 관리 코드는 최대한 분리한다.

## 5. 테스트 가능성

- 각 계층별로 독립적으로 테스트가 가능하도록 설계한다.

## 6. 리팩토링 순서

1. 컴포넌트 역할별 분리 (UI/관리/비즈니스)
2. models(순수함수)로 핵심 로직 분리
3. hooks로 상태 관리/side effect 분리
4. 컴포넌트와 hook 연결
5. 테스트 및 검증

## 7. 기타 원칙

- 불변성(immutable)을 지키며, 기존 객체/배열을 직접 변경하지 않는다.
- 중복 로직은 반드시 함수로 추출해 재사용한다.
- 코드의 의도를 주석과 타입으로 명확히 표현한다.

---

## 실제 진행한 리팩토링 단계 예시

1. **컴포넌트 분리**

   - `AdminPage`, `CartPage` 등 UI 역할별로 컴포넌트 분리

2. **비즈니스 로직 분리(모델)**

   - `models/cart.ts`, `models/product.ts`, `models/coupon.ts`, `models/discount.ts` 등 엔티티별 핵심 로직을 순수함수로 분리
   - 할인, 쿠폰, 상품, 장바구니 등 핵심 계산/검증 로직을 UI/상태와 분리

3. **상태 관리 로직 분리(hook)**

   - `useCart`, `useProducts`, `useCoupons` 등 상태 관리와 side effect를 hook으로 분리
   - hook 내부에서 models의 순수함수를 활용하도록 리팩토링

4. **컴포넌트와 hook 연결**

   - 컴포넌트에서 hook을 사용해 UI와 상태/비즈니스 로직을 연결

5. **테스트 및 검증**
   - 각 계층별로 테스트 코드가 통과하는지 확인

이 기준을 바탕으로 앞으로 모든 리팩토링 작업을 일관성 있게 진행한다.
